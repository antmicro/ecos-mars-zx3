<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
		<title>IO/CAN Doc</title>
	</head>

	<body bgcolor="#ffffff">
		<h2>CAN driver details</h2>
		<p>A raw CAN driver is is provided as a standard part of the eCos system. Use the include file <code>&lt;cyg/io/canio.h&gt;</code> for this driver. The CAN driver is capable of sending single CAN messages and receiving single CAN events to a CAN device. Controls are provided to configure the actual hardware, but there is no manipulation of the data by this driver. There may be many instances of this driver in a given system, one for each CAN channel. Each channel corresponds to a physical device and there will typically be a device module created for this purpose. The device modules themselves are configurable, allowing specification of the actual hardware details.</p>
		<h3>User API</h3>
		<p>The CAN driver  uses the standard eCos I/O API functions. All functions except <code>cyg_io_lookup()</code> require an I/O &quot;handle&quot;.</p>
		<p>All functions return a value of the type <code>Cyg_ErrNo</code>. If an error condition is detected, this value will be negative and the absolute value indicates the actual error, as specified in <code>cyg/error/codes.h</code>. The only other legal return value will be <code>ENOERR</code> , <code>-EINTR </code>and<code> -EAGAIN</code>. All other function arguments are pointers (references). This allows the drivers to pass information efficiently, both into and out of the driver. The most striking example of this is the <i>len </i>value passed to the read and write functions. This parameter contains the desired length of data on input to the function and the actual transferred length on return.</p>
		<h4>Lookup a CAN device</h4>
		<p><code>Cyg_ErrNo cyg_io_lookup(<br>&nbsp;&nbsp;&nbsp;&nbsp;const char &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*name,<br>&nbsp;&nbsp;&nbsp;&nbsp;cyg_io_handle_t *handle )</code></p>
		<p>This function maps a device name onto an appropriate handle. If the named device is not in the system, then the error -<code>ENOENT</code> is returned. If the device is found, then the handle for the device is returned by way of the handle pointer <i>*handle</i>.</p>
		<h4>Send a CAN message</h4>
		<p><code>Cyg_ErrNo cyg_io_write(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_io_handle_t &nbsp;handle,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;const void &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*buf,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint32 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*len )<br>
			</code></p>
		<p>This function sends <b>one single</b> CAN message (not a buffer of  CAN messages) to a device. The size of data to send is contained in <i>*len</i> and the actual size sent will be returned in the same place. A pointer to a <code>cyg_can_message</code> is contained in <i>*buf</i> . The driver maintains a buffer to hold the data. The size of the intermediate buffer is configurable within the interface module. The data is not modified at all while it is being buffered. On return,<i> *len</i> contains the amount of characters actually consumed - that means <i>*len</i> always contains <code>sizeof(cyg_can_message)</code>.</p>
		<p>It is possible to configure the write call to be blocking (default) or non-blocking. Non-blocking mode requires both the configuration option <code>CYGOPT_IO_CAN_SUPPORT_NONBLOCKING</code> to be enabled, and the specific device to be set to non-blocking mode for writes (see <code>cyg_io_set_config()</code>). In blocking mode, the call will not return until there is space in the buffer and the content of the CAN message has been consumed. In non-blocking mode, if there is no space in buffer for the CAN message, <code>-EAGAIN</code> is returned and the caller must try again.</p>
		<p>It is possible to configure the write call to be non-blocking with timeout. None-blocking mode with timeout requires the configuration option <code>CYGOPT_IO_CAN_SUPPORT_NONBLOCKING </code>and<code> CYGOPT_IO_CAN_SUPPORT_TIMEOUTS </code>to be enabled, requires the eCos kernel package to be included and the specific device to be set to non-blocking mode for writes (see <code>cyg_io_set_config()</code>). In non-blocking mode with timeouts, if there is no space in buffer for the CAN message, the driver waits a certain amount of time (the timeout time) for space in the buffer. If there is still no space in buffer after expiration of the timeout time, <code> -EINTR</code> is returned and the caller must try again.</p>
		<p>If a message was sucessfully sent, the function returns <code>ENOERR</code>. </p>
		<p><code>typedef struct can_message<br>
				
				{<br>
				
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint32 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id;<br>
				
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint8 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data[8];<br>
				
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_can_id_type &nbsp;&nbsp;&nbsp;ext;<br>
				
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_can_frame_type rtr;<br>
				
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint8 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlc;<br>
				
				} cyg_can_message;</code></p>
		<p>The type <code>cyg_can_message</code> provides a device independent type of CAN message. Before calling the write function this message should be setup properly. The<i> id</i> field contains the 11 Bit or 29 bit CAN message identifier depending on the value of the <i>ext</i> field. The <i>data</i> field contains the 8 data bytes of one CAN message. The <i>ext</i> field configures the type of CAN message identifier (<code>CYGNUM_CAN_ID_STD</code> = standard 11 Bit id,<i> </i><code>CYGNUM_CAN_ID_EXT</code> = extended 29 Bit id). The <i>rtr</i> field contains the frame type. (<code>CYGNUM_CAN_FRAME_DATA</code> = data frame, <code>CYGNUM_CAN_FRAME_RTR</code> = remote transmission request). The <i>dlc</i> field (data length code) contains the number of valid data bytes (0 - 8) in the <i>data</i> field.</p>
		<p>Example code for sending one single CAN message:</p>
		<p><code>cyg_can_message tx_msg;<br>cyg_uint32 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len;<br>
				Cyg_ErrNo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret;<br>
				<br>
				
				
				tx_msg.id &nbsp;= 0x100;<br>
				
				
				tx_msg.ext = CYGNUM_CAN_ID_EXT;<br>
				
				tx_msg.rtr = CYGNUM_CAN_FRAME_DATA;<br>
				
				tx_msg.dlc = 1;<br>
				
				tx_msg.data[0] = 0xF1;<br>
				<br>
				
				len = sizeof(tx_msg);<br>
				ret = cyg_io_write(hDrvCAN, &amp;tx_msg, &amp;len);</code></p>
		<h4>Read a CAN event</h4>
		<p><code>Cyg_ErrNo cyg_io_read(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_io_handle_t &nbsp;handle,<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;void &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*buf,<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint32 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*len )<br>
			</code></p>
		<p>This function receives one single event from a device. The desired size of data to receive is contained in <i>*len</i> and the actual size obtained will be returned in the same place. A pointer to a<code> cyg_can_event</code> is contained in <i>*buf</i>. No manipulation of the data is performed before being transferred. Again, this buffering is completely configurable. On return, <i>*len</i> contains  <code>sizeof(cyg_can_event)</code><br>
		</p>
		<p>It is possible to configure the read call to be blocking (default) or non-blocking. Non-blocking mode requires both the configuration option <code>CYGOPT_IO_CAN_SUPPORT_NONBLOCKING</code> to be enabled, and the specific device to be set to non-blocking mode for reads (<code>see cyg_io_set_config()</code>). In blocking mode, the call will not return until one single CAN event has been read. In<i> </i>non-blocking mode, if there is no CAN event in buffer, the call returns immediately with <code>-EAGAIN</code> and the caller must try again.</p>
		<p>It is possible to configure the write call to be non-blocking with timeout. None-blocking mode with timeout requires the configuration option <code>CYGOPT_IO_CAN_SUPPORT_NONBLOCKING </code>and<code> CYGOPT_IO_CAN_SUPPORT_TIMEOUTS </code>to be enabled, requires the eCos kernel package to be included and the specific device to be set to non-blocking mode for reads (see <code>cyg_io_set_config()</code>). In non-blocking mode with timeouts, if there is no CAN event in receive buffer, the driver waits a certain amound of time (the timeout time) for a CAN event to arrive. If there is still no CAN event in buffer after expiration of the timeout time, <code> -EINTR</code> is returned and the caller must try again.</p>
		<p>If an event was sucessfully received, the function returns <code>ENOERR</code>.</p>
		<p><code>typedef struct cyg_can_event_st<br>
				{<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp;<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_can_message msg;<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flags;<br>
				} cyg_can_event;<br>
			</code></p>
		<p>A <code>cyg_can_event</code>  provides a generic device independent type for handling CAN events that may occur. If the driver supports timestamps then the <i>timestamp</i> field my contain a timestamp value for an event that occured. The <i>msg</i> field contains a CAN message if an RX or TX event occured. The <i>flags</i> field contains 16 bits that indicate which kind of events occured. The following events are supported and after receiving an event the flag field should be checked against these values:</p>
		<p><code>typedef enum <br>
				{<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_RX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0001, // message received<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_TX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0002, // mesage transmitted<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_WARNING_RX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0004, // tx error counter (TEC) reached warning level (&gt;96)<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_WARNING_TX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0008, // rx error counter (REC) reached warning level (&gt;96)<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_ERR_PASSIVE &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0010, // CAN &quot;error passive&quot; occured<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_BUS_OFF &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0020, // CAN &quot;bus off&quot; error occured<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_OVERRUN_RX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0040, // overrun in RX queue or hardware occured<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_OVERRUN_TX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0080, // overrun in TX queue occured<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_CAN_ERR &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x0100, // a CAN bit or frame error occured<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_LEAVING_STANDBY &nbsp;= 0x0200, // CAN hardware leaves standby / power don mode or is waked up<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_ENTERING_STANDBY = 0x0400, // CAN hardware enters standby / power down mode<br>
				
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_ARBITRATION_LOST = 0x0800, // arbitration lost<br>
				&nbsp;&nbsp;CYGNUM_CAN_EVENT_DEVICE_CHANGED &nbsp;&nbsp;= 0x1000, // device changed event<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_EVENT_PHY_FAULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x2000, // General failure of physical layer detected (if supported by hardware)<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_EVENT_PHY_H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x4000, // Fault on CAN-H detected (Low Speed CAN)<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_EVENT_PHY_L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0x8000, // Fault on CAN-L detected (Low Speed CAN)<br>
				} cyg_can_event_flags;</code></p>
		<p>Often the flags field will contain only one single set flag. But it is possible that a number of flags is set and so the flag field should always be checked by a receiver. I.e. if the <code>CYGNUM_CAN_EVENT_RX </code>is set then also the <code>CYGNUM_CAN_EVENT_OVERRUN_RX </code>may be set if the received message caused an RX overrun.</p>
		<p>The internal receive buffers of the CAN device driver a circular buffers. That means that even if the buffers are completely filled new messages will be received. In this case the newest message will always overwrite the oldest message in receive buffer. If this happens the <code>CYGNUM_CAN_EVENT_OVERRUN_RX </code>flag will be set for this new message that caused overwriting of the old one. The <code>CYGNUM_CAN_EVENT_OVERRUN_RX </code>flag will be set also if a overrun occures in hardware message buffers of the CAN device.</p>
		<p>Example code for receiving one single CAN event:</p>
		<p><code>cyg_can_event rx_event;<br>
				cyg_uint32 &nbsp;&nbsp;&nbsp;len;<br>
				Cyg_ErrNo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret;<br>
				<br>
				
				len = sizeof(rx_event);<br>
				
				ret = cyg_io_read(hDrvCAN, &amp;rx_event, &amp;len);<br>
				<br>
				
				if (ENOERR == ret)<br>
				
				{<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;if (rx_event.flags &amp; CYGNUM_CAN_EVENT_RX)<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;{<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// handle RX event<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;}<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(rx_event.flags &amp; ~CYGNUM_CAN_EVENT_RX)<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;{<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// handle other events<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;}<br>
				
				}<br>
				
				else if (-EINTR == ret)<br>
				
				{<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;// handle timeout<br>
				
				}<br>
			</code></p>
		<h4>Read configuration of a CAN device</h4>
		<p><code>Cyg_ErrNo cyg_io_get_config(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_io_handle_t handle,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint32 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;void &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*buf,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint32 &nbsp;&nbsp;&nbsp;&nbsp;*len )<br>
			</code></p>
		<p>This function is used to obtain run-time configuration about a device. The type of information retrieved is specified by the key. The data will be returned in the given buffer. The value of <i>*len</i> should contain the amount of data requested, which must be at least as large as the size appropriate to the selected key. The actual size of data retrieved is placed in <i>*len</i>. The appropriate key values are all listed in the file<code> &lt;cyg/io/config_keys.h&gt;</code>.</p>
		<p>The following config keys are currently supported:</p>
		<p><code>CYG_IO_GET_CONFIG_READ_BLOCKING<br>
				CYG_IO_GET_CONFIG_WRITE_BLOCKING<br>
				CYG_IO_GET_CONFIG_CAN_INFO<br>
				CYG_IO_GET_CONFIG_CAN_BUFFER_INFO<br>CYG_IO_GET_CONFIG_CAN_MSGBUF_INFO<br>
				
				CYG_IO_GET_CONFIG_CAN_TIMEOUT<br>
				CYG_IO_GET_CONFIG_CAN_HDI<br>
				CYG_IO_GET_CONFIG_CAN_STATE<br>
			</code></p>
		<h4>Change configuration of a CAN device</h4>
		<p><code>Cyg_ErrNo cyg_io_set_config(<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_io_handle_t &nbsp;handle,<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint32 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key,<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;const void &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*buf,<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint32 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*len)<br>
			</code></p>
		<p>This function is used to manipulate or change the run-time configuration of a device. The type of information is specified by the key. The data will be obtained from the given buffer. The value of <i>*len</i> should contain the amount of data provided, which must match the size appropriate to the selected key. The appropriate key values are all listed in the file <code>&lt;cyg/io/config_keys.h&gt;</code>.</p>
		<p>The following config keys are currently supported:</p>
		<p><code>CYG_IO_SET_CONFIG_READ_BLOCKING<br>
				CYG_IO_SET_CONFIG_WRITE_BLOCKING<br>
				CYG_IO_SET_CONFIG_CAN_INFO<br>
				CYG_IO_SET_CONFIG_CAN_OUTPUT_DRAIN<br>
				CYG_IO_SET_CONFIG_CAN_OUTPUT_FLUSH<br>
				CYG_IO_SET_CONFIG_CAN_INPUT_FLUSH<br>
				
				
				CYG_IO_SET_CONFIG_CAN_TIMEOUT<br>CYG_IO_SET_CONFIG_CAN_MSGBUF<br>
			</code><code>CYG_IO_SET_CONFIG_CAN_MODE<br>
				<br>
			</code></p>
		<h3>Runtime Configuration</h3>
		<p>Runtime configuration is achieved by exchanging data structures with the driver via the <code>cyg_io_set_config()</code> and <code>cyg_io_get_config()</code> functions.</p>
		<h4>Device configuration</h4>
		<p><code>typedef struct cyg_can_info_st {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_can_baud_rate_t   baud;<br>
				} cyg_can_info_t;</code></p>
		<p>Device configuration is achieved by  by exchanging <code>cyg_can_info_t </code>data structures with the driver via the <code>cyg_io_set_config()</code> and <code>cyg_io_get_config()</code> functions using the config keys <code>CYG_IO_GET_CONFIG_CAN_INFO </code>and<code> CYG_IO_SET_CONFIG_CAN_INFO</code>. The field <i>baud</i> contains a baud rate selection. This must be one of the follwing values:</p>
		<p><code>CYGNUM_CAN_KBAUD_10<br>
				CYGNUM_CAN_KBAUD_20<br>
				CYGNUM_CAN_KBAUD_50<br>
				CYGNUM_CAN_KBAUD_100<br>
				CYGNUM_CAN_KBAUD_125<br>
				CYGNUM_CAN_KBAUD_250<br>
				CYGNUM_CAN_KBAUD_500<br>
				CYGNUM_CAN_KBAUD_800<br>
				CYGNUM_CAN_KBAUD_1000<br>
			</code></p>
		<h4>Timeout configuration</h4>
		<p><code>typedef struct cyg_can_timeout_info_st<br>
				{<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint32 rx_timeout; <br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint32 tx_timeout;<br>
				} cyg_can_timeout_info_t;<br>
			</code></p>
		<p>Timeout configuration is achieved by by exchanging <code>cyg_can_timeout_info_t </code>data structures with the driver via the <code>cyg_io_set_config()</code> and <code>cyg_io_get_config()</code> functions using the config keys <code>CYG_IO_SET_CONFIG_CAN_TIMEOUT </code>and<code> CYG_IO_SET_CONFIG_CAN_TIMEOUT</code>.  The field <i>rx_timeout</i> contains the timeout value for <code>cyg_io_read </code>calls and <i>tx_timeout</i> contains the timeout value for  <code>cyg_io_write </code>calls. This call is only available if the configuration options <code>CYGOPT_IO_CAN_SUPPORT_NONBLOCKING  </code>and <code>CYGOPT_IO_CAN_SUPPORT_TIMEOUTS</code> are enabled.</p>
		<h4>Reading buffer configuration</h4>
		<p><code>typedef struct cyg_can_buf_info_st<br>
				{  <br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_int32 rx_bufsize; <br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_int32 rx_count;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_int32 tx_bufsize;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_int32 tx_count;<br>
				} cyg_can_buf_info_t;<br>
			</code></p>
		<p><code>CYG_IO_GET_CONFIG_CAN_BUFFER_INFO - </code>This function retrieves the current state of the software buffers in the serial drivers. For the transmit buffer it returns the the total number of  <code>cyg_can_message </code>objects in buffer and the current number of  <code>cyg_can_message </code>objects occupied in the buffer. For the recieve buffer it returns the total number of  <code>cyg_can_event </code>objects in receive buffer and the current number of  <code>cyg_can_event </code>objects occupied  in the buffer. It does not take into account any buffering such as FIFOs or holding registers that the CAN hardware device itself may have.</p>
		<h4>Reading hardware description information</h4>
		<p><code>typedef struct cyg_can_hdi_st<br>
				{<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint8 support_flags;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_uint8 controller_type;<br>
				} cyg_can_hdi;</code></p>
		<p><code>CYG_IO_GET_CONFIG_CAN_HDI - </code>This function retrieves information about the used hardware. The Hardware Description Interface provides a method to gather information about the CAN hardware and the functionality of the driver. For this purpose the structure <code>cyg_can_hdi </code>is defined. The field support_flags contains information about the capabilities of the used CAN hardware. The following flags are available:</p>
		<table width="600" border="0" cellspacing="2" cellpadding="0">
			<tr>
				<td align="center" valign="middle" bgcolor="#c6c6c6" width="70">7</td>
				<td align="center" valign="middle" bgcolor="#c6c6c6" width="70">6</td>
				<td align="center" valign="middle" bgcolor="#c6c6c6" width="70">5</td>
				<td align="center" valign="middle" bgcolor="#c6c6c6" width="70">4</td>
				<td align="center" valign="middle" bgcolor="#c6c6c6" width="70">3</td>
				<td align="center" valign="middle" bgcolor="#c6c6c6" width="70">2</td>
				<td align="center" valign="middle" bgcolor="#c6c6c6" width="70">1</td>
				<td align="center" valign="middle" bgcolor="#c6c6c6" width="70">0</td>
			</tr>
			<tr>
				<td align="center" valign="middle" width="70">res</td>
				<td align="center" valign="middle" width="70">res</td>
				<td align="center" valign="middle" width="70">res</td>
				<td align="center" valign="middle" width="70">timest.</td>
				<td align="center" valign="middle" width="70">SW-Filt</td>
				<td align="center" valign="middle" width="70">FullCAN</td>
				<td colspan="2" align="center" valign="middle" width="142">Frametype</td>
			</tr>
		</table>
		<p><i>Frametype:<br>
			</i>Bit 0 and Bit 1 of the structure describe the<i> </i>possibilities of the CAN controller. The following values are defined:</p>
		<p><code>CYGNUM_CAN_HDI_FRAMETYPE_STD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// receives only standard frame<br>
				CYGNUM_CAN_HDI_FRAMETYPE_EXT_PASSIVE&nbsp;&nbsp;// can recieve but not send extended frames<br>
				CYGNUM_CAN_HDI_FRAMETYPE_EXT_ACTIVE&nbsp;&nbsp;&nbsp;// can send and receive extended frames<br>
			</code></p>
		<p><i>FullCAN:<br>
			</i>If the Bit 2 is set to one, the CAN controller supports more than one message buffer.</p>
		<p><code>CYGNUM_CAN_HDI_FULLCAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// supports more than one message buffer<br>
			</code></p>
		<p><i>SW-Filter:<br>
			</i>If Bit3 is set to one then the CAN driver supports some kind of software message filtering.</p>
		<p><code>CYGNUM_CAN_HDI_FILT_SW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// software message filtering supported<br>
			</code></p>
		<p><i>Timestamp:<br>
			</i>If Bit 4 is set to one then the CAN hardware supports timestamps for CAN messages</p>
		<p><code>CYGNUM_CAN_HDI_TIMESTAMP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// CAN hardware supports timestamps<br>
			</code></p>
		<h4>Reading message buffer configuration</h4>
		<p><code>typedef struct cyg_can_msgbox_info_st<br>
			</code><code>{<br>
				&nbsp;&nbsp;&nbsp;&nbsp;c</code><code>yg_uint8 count;    // number of message buffers available for this device<br>
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cyg_uint8 free; &nbsp;// number of free message buffers<br>
			</code><code>} cyg_can_msgbuf_info;</code></p>
		<p><code>CYG_IO_GET_CONFIG_CAN_MSGBUF_INFO</code> - If the CAN hardware supports more than one message buffer for reception of CAN message (flag <code>CYGNUM_CAN_HDI_FULLCAN </code>is set after reading hardware description interface with <code>CYG_IO_GET_CONFIG_CAN_HDI</code>) then this function reads the number of message buffers the CAN hardware supports and the number of free message buffers. The field<i> count</i> contains the number of message buffers supported by device and the field <i>free</i> contains the number of free message buffers. The free message buffers are available for setting up remote buffers (<code>CYG_IO_SET_CONFIG_CAN_REMOTE_BUF)</code> and message filters (<code>CYG_IO_SET_CONFIG_CAN_FILTER_MSG</code>).</p>
		<h4>Reading state of CAN hardware</h4>
		<p><code>typedef enum<br>
				{<br>&nbsp;&nbsp;CYGNUM_CAN_STATE_ACTIVE, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// CAN controller is active, no errors<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_STATE_STOPPED, &nbsp;&nbsp;&nbsp;&nbsp;// CAN controller is in stopped mode<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_STATE_STANDBY, &nbsp;&nbsp;&nbsp;&nbsp;// CAN controller is in Sleep mode<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_STATE_BUS_WARN, &nbsp;&nbsp;&nbsp;// CAN controller is active, warning level is reached<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_STATE_ERR_PASSIVE,  // CAN controller went into error passive mode<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_STATE_BUS_OFF,&nbsp;&nbsp;&nbsp;&nbsp; // CAN controller went into bus off mode<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_STATE_PHY_FAULT, &nbsp;&nbsp;// General failure of physical layer detected (if supported by hardware)<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_STATE_PHY_H, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Fault on CAN-H detected (Low Speed CAN)<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_STATE_PHY_L, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Fault on CAN-L detected (Low Speed CAN)<br>
			</code><code>} cyg_can_state;</code></p>
		<p><code>CYG_IO_GET_CONFIG_CAN_STATE</code> - This function retrieves the present state of the CAN controller. Possible values are defined in the <code>cyg_can_state</code> enumeration.</p>
		<h4>Drain output buffers</h4>
		<p><code>CYG_IO_SET_CONFIG_CAN_OUTPUT_DRAIN</code> - This function waits for any buffered output to complete. This function only completes when there is no more data remaining to be sent to the device.</p>
		<h4>Flush output buffers</h4>
		<p><code>CYG_IO_SET_CONFIG_CAN_OUTPUT_FLUSH</code> - This function discards any buffered output for the device.</p>
		<h4>Flush input buffers</h4>
		<p><code>CYG_IO_SET_CONFIG_CAN_INPUT_FLUSH</code> - This function discards any buffered input for the device.</p>
		<h4>Configuring blocking/nonblocking calls</h4>
		
		
		
		
		By default all calls to <code>cyg_io_read()</code> and<code> cyg_io_write()</code> are blocking calls. The config keys<br>
		<br>
		<code>CYG_IO_GET_CONFIG_READ_BLOCKING<br>
			CYG_IO_GET_CONFIG_WRITE_BLOCKING<br>
			<br>
		</code>and<br>
		<br>
		<code>CYG_IO_GET_CONFIG_READ_BLOCKING<br>
			CYG_IO_GET_CONFIG_WRITE_BLOCKING<br>
			<br>
		</code>enable switching between blocking and nonblocking calls separatly for read and write calls. If  blocking calls are configured then the read/write functions return only if a message was stored into TX buffer or an event was received from RX buffer. If nonblocking calls are enabled and there is no space in TX buffer or RX buffer is empty then the function returns immediatelly with <code>-EAGAIN</code>. If nonblocking calls are enabled and additionally timeouts are supported by driver, then the read/write functions wait until timeout value is expired and then return witn <code>-EINTR</code>. If the read/write operation succeeds during the timed wait then the functions return succesfully with<code> ENOERR</code>.

		<h4>Message buffer configuration</h4>
		<p><code>typedef struct cyg_can_msgbox_cfg_st<br>
			</code><code>{<br>
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cyg_can_msgbuf_cfg_id  cfg_id; // configuration id - cfg. what to do with message buffer<br>
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cyg_can_msgbuf_handle  handle; // handle to message buffer<br>
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cyg_can_message msg; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// CAN message - for configuration of buffer<br>
			</code><code>} cyg_can_msgbuf_cfg;</code></p>
		<p>Full CAN controllers often support more the one message buffer. These message buffers are often configurable for transmission or reception of certain CAN messages or as a remote buffer. If a CAN hardware supports more than one message buffer then it is possible to configure the CAN hardware to receive only CAN messages with certain identifiers or to configure hardware support for remote buffers. If message filtering is done by hardware, the number of received CAN messages decreases and so also the time for processing received CAN messages and the memory required for buffering received messages decreases. This saves valuable memory and processing time. The eCos CAN driver supports a generic way of adding message filters or remote buffers. By default the CAN driver is configured for reception of any kind of CAN standard and extended frames. Configuration of message buffers is done by calling <code>cyg_io_set_config() </code>with the config key:</p>
		<p><code>CYG_IO_SET_CONFIG_CAN_MSGBUF<br>
			</code></p>
		<p>and exchanging  <code>cyg_can_msgbuf_cfg </code>data structures. The <i>cfg_id</i> field contains the configuration ID that tells the driver what to do with a message buffer, the <i>handle</i> field contains a reference to a certain message buffer and the <i>msg</i> field is necessary for configuration of message buffer parameters. The following configuration identifiers are supported:</p>
		<p><code>CYGNUM_CAN_MSGBUF_RESET_ALL &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// clears all message buffers, no message will be received, all remote buffers deleted<br>
			</code><code>CYGNUM_CAN_MSGBUF_RX_FILTER_ALL &nbsp;&nbsp;&nbsp;// cfg driver for reception of all can messges<br>
			</code><code>CYGNUM_CAN_MSGBUF_RX_FILTER_ADD &nbsp;&nbsp;&nbsp;// add single message filter<br>
			</code><code>CYGNUM_CAN_MSGBUF_REMOTE_BUF_ADD &nbsp;&nbsp;// add new remote response buffer<br>
			</code><code>CYGNUM_CAN_MSGBUF_REMOTE_BUF_WRITE // stores data into existing remote buffer (remote buf handle required)</code></p>
		<p>Example code for resetting all message buffers:</p>
		<p><code>cyg_can_msgbuf_cfg     msgbox_cfg;</code></p>
		<p><code>msgbox_cfg.cfg_id = CYGNUM_CAN_MSGBUF_RESET_ALL;<br>
			</code><code>len = sizeof(msgbox_cfg);<br>
			</code><code>if (ENOERR != cyg_io_set_config(hDrvFlexCAN, CYG_IO_SET_CONFIG_CAN_MSGBUF ,&amp;msgbox_cfg, &amp;len))<br>
			</code><code>{<br>
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// handle configuration error<br>
			</code><code>} </code></p>
		<h4>Remote frame response buffer configuration</h4>
		<p>The remote frame is a message frame which is transmitted to request a data frame. Some CAN hardware generates receive interrupts when a remote transmission request arrives. Other CAN hardware, i.e. the FlexCAN module, does not generate any receive interrupt. These CAN hardware chips, i.e. the FlexCAN module, can be configured to transmit a data frame automatically in response to a remote frame. In oder to support any kind of CAN hardware the eCos CAN driver provides a generic handling of remote transmission requests.</p>
		<p>The transmission of the data frame in response to a remote frame is completely handled by the CAN driver. If the hardware driver, like the driver for the FlexCAN modul, supports harware message buffers, then the response frame is automatically transmitted if a remote transmission request with a matching ID arrives. If a CAN hardware does not provide hardware support for sending data frames in response to a remote frame, then this need to be implemented in software by the hardware device driver.</p>
		<p>It is always possible to add remote response buffers. It does not matter if the driver is configured for reception of all CAN messages or if message filtering is used.&nbsp;As long as there are free message buffers available, it is possible to add remote response buffers.</p>
		<p>In order to respond to a remote frame, a remote frame reponse buffer need to be initialized before a data frame can be sent in response to a remote frame. This is achieved by by exchanging <code>cyg_can_remote_buf </code>data structures with the driver via the <code>cyg_io_set_config()</code> function using the config key <code>CYG_IO_SET_CONFIG_CAN_MSGBUF</code>. Once the buffer is initialized, the CAN data can be changed at any time by the application.</p>
		<p><code>typedef struct cyg_can_msgbuf_cfg_st<br>
			</code><code>{<br>&nbsp;&nbsp;&nbsp;&nbsp;cyg_can_msgbuf_cfg_id cfg_id; // configuration id - cfg. what to do with message buffer<br>
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cyg_can_msgbuf_handle  handle; // handle to message buffer<br>
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cyg_can_message msg; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// CAN message - for configuration of buffer<br>
				} cyg_can_remote_buf;<br>
			</code></p>
		<p>The CAN frame that should be transmitted in response to a remote frame is stored in the<i> msg</i> field of the <code>cyg_can_remote_buf </code>data structure. If there is no buffer initialized for this data, the value of the <i>handle</i> field need to be set to <code>CYGNUM_CAN_MSGBUF_INIT</code>. After the call to <code>cyg_io_set_config()</code> the <i>handle</i> field contains a valid value ( &gt;= 0) or the value <code>CYGNUM_CAN_MSGBUF_NA</code>  ( &lt; 0) if no free buffer is available. With the valid handle value the CAN data can be changed later by calling  <code>cyg_io_set_config(). </code>Before adding remote buffers the device should be stopped and after configuration it should be set into operational mode again</p>
		<p>Example code for setting up a remote response buffer:</p>
		<p><code>cyg_can_remote_buf rtr_buf;<br>
				<br>
				// prepare the remote response buffer<br>rtr_buf.cfg_id &nbsp;= CYGNUM_CAN_MSGBUF_REMOTE_BUF_ADD;<br>
			</code><code>rtr_buf.handle &nbsp;= CYGNUM_CAN_MSGBUF_INIT;<br>
			</code><code>rtr_buf.msg.id&nbsp; = 0x7FF;<br>
			</code><code>rtr_buf.msg.ext     = CYGNUM_CAN_ID_STD;<br>
			</code><code>rtr_buf.msg.rtr     = CYGNUM_CAN_FRAME_DATA;<br>
			</code><code>rtr_buf.msg.dlc     = 1;<br>
			</code><code>rtr_buf.msg.data[0] = 0xAB;<br>
				<br>
				
				len = sizeof(rtr_buf);<br>
			</code><code>if (ENOERR != cyg_io_set_config(hDrvFlexCAN, <br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CYG_IO_SET_CONFIG_CAN_MSGBUF,<br>
				
				
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;rtr_buf, &amp;len))<br>
			</code><code>{<br>
				
				
				&nbsp;&nbsp;&nbsp;&nbsp;// handle configuration error<br>
			</code><code>} <br>
			</code><code><br>
			</code><code>if (rtr_buf.handle == CYGNUM_CAN_MSGBUF_NA)<br>
			</code><code>{<br>
				
				
				&nbsp;&nbsp;&nbsp;&nbsp;// no free message buffer available - handle this problem here<br>
			</code><code>}<br>
				<br>
				<br>
				
				// change CAN data for a buffer that is already initialized<br>
			</code><code>rtr_buf.cfg_id      = CYGNUM_CAN_MSGBUF_REMOTE_BUF_WRITE;<br>
				
				
				rtr_buf.msg.data[0] = 0x11;<br>
				<br>
				
				
				len = sizeof(rtr_buf);<br>
			</code><code>if (ENOERR != cyg_io_set_config(hDrvFlexCAN, <br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CYG_IO_SET_CONFIG_CAN_MSGBUF,<br>
				
				
				
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;rtr_buf, &amp;len))<br>
			</code><code>{<br>
				
				
				
				&nbsp;&nbsp;&nbsp;&nbsp;// handle configuration error<br>
			</code><code>} <br>
			</code></p>
		<h4>Message filter configuration</h4>
		<p> If message filtering is done by hardware the number of received CAN messages decreases and so also the time for processing received CAN messages and the memory required for buffering received messages decreases. This saves valuable memory and processing time. The eCos CAN driver supports a generic way of adding message filters. By default the CAN driver is configured for reception of any kind of CAN standard and extended frames. As soon as a message filter is added, the CAN driver will only receive the CAN frames with the identifier of the CAN filter. By adding a number of message filters it is possible for the CAN hardware to receive an number of different CAN messages.</p>
		<p>Adding message filters is only possible if driver is not configured for reception of all available CAN messages. If driver is configured for recption of all CAN messages then message buffers neet to be reset before adding single message filters.</p>
		<p>In order to add a message filter, a message buffer need to be initialized. This is achieved by by exchanging <code>cyg_can_filter </code>data structures with the driver via the <code>cyg_io_set_config()</code> function using the config key <code>CYG_IO_SET_CONFIG_CAN_MSGBUF</code>. Once the buffer is initialized, the CAN hardware can recive messages with the identifier of the filter.</p>
		<p><code>typedef struct cyg_can_msgbox_cfg_st<br>
			</code><code>{<br>
				&nbsp;&nbsp;&nbsp;&nbsp;cyg_can_msgbuf_cfg_id cfg_id;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cyg_can_msgbuf_handle  handle;<br>
				
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>cyg_can_message &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg;<br>
			</code><code>} cyg_can_filter;</code></p>
		<p>After the call to <code>cyg_io_set_config()</code> the <i>handle</i> field contains a valid value ( &gt;= 0) or the value <code>CYGNUM_CAN_MSGBUF_NA</code> ( &lt; 0) if no free buffer is available. Before adding message filters the device should be stopped and after configuration it should be set into operational mode again</p>
		<p>Example code for setting up a message filter:</p>
		<p><code>cyg_can_msgbuf_cfg  msgbox_cfg;<br>
				cyg_can_filter      rx_filter;<br>
				<br>
				// reset all message buffers</code><br>
			<code>msgbox_cfg.cfg_id = CYGNUM_CAN_MSGBUF_RESET_ALL;<br>
			</code><code>len = sizeof(msgbox_cfg);<br>
			</code><code>if (ENOERR != cyg_io_set_config(hDrvFlexCAN, CYG_IO_SET_CONFIG_CAN_MSGBUF ,&amp;msgbox_cfg, &amp;len))<br>
			</code><code>{<br>
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// handle configuration error<br>
			</code><code>} <br>
				<br>
			</code><code>// prepare the message filter<br>
				rx_filter.cfg_id  = CYGNUM_CAN_MSGBUF_RX_FILTER_ADD<br>
			</code><code>rx_filter.msg.id &nbsp;= 0x800;<br>
				rx_filter.msg.ext = CYGNUM_CAN_ID_EXT;<br>
				<br>
				len = sizeof(rx_filter);<br>
				if (ENOERR != cyg_io_set_config(hDrvFlexCAN,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CYG_IO_SET_CONFIG_CAN_MSGBUF,<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;rx_filter, &amp;len))<br>
			</code><code>{<br>
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>// handle configuration error;<br>
			</code><code>}<br>
			</code><code>else if (CYGNUM_CAN_MSGBUF_NA == rx_filter.handle)<br>
			</code><code>{<br>
				&nbsp;&nbsp;&nbsp;&nbsp;// no free message buffer available - handle this problem here<br>
				}</code></p>
		<h4>Receive all CAN  messages</h4>After startup of your device the CAN driver is configured for reception of all available CAN messages. If you change this configuration by adding single message filters then you can reset this default state with the configuration ID:		<p><code>CYGNUM_CAN_MSGBUF_RX_FILTER_ALL</code> </p>
		<p>A call to this function will clear all message filters and remote buffers and prepares the CAN hardware for recption of any kind of CAN standard and extended frames. It is not neccesary to reset the message buffer configuration before this configuration is setup because this should be done by device driver.</p>
		<p>Example code for setup of a receive all CAN frames configuration:</p>
		<p><code>cyg_can_filter rx_filter;<br>
				<br>
				// now setup a RX all configuration<br>
			</code><code>rx_filter.cfg_id  = CYGNUM_CAN_MSGBUF_RX_FILTER_ALL;<br>
			</code><code>len = sizeof(rx_filter);<br>
			</code><code>if (ENOERR != cyg_io_set_config(hDrvFlexCAN, CYG_IO_SET_CONFIG_CAN_MSGBUF , &amp;rx_filter, &amp;len))<br>
			</code><code>{<br>
				&nbsp;&nbsp;&nbsp;&nbsp;</code><code>CYG_TEST_FAIL_FINISH(&quot;Error writing config of /dev/can0&quot;);<br>
			</code><code>}</code></p>
		<h4>Set mode of CAN hardware</h4>
		<p><code>typedef enum <br>
			</code><code>{<br>
				&nbsp;&nbsp;CYGNUM_CAN_MODE_STOP,&nbsp;&nbsp;&nbsp;// set controller into stop mode<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_MODE_START,&nbsp;&nbsp;// set controller into operational mode<br>
				&nbsp;&nbsp;</code><code>CYGNUM_CAN_MODE_STANDBY&nbsp;// set controller into standby / sleep mode<br>
				} cyg_can_mode;</code></p>
		<p><code>CYG_IO_SET_CONFIG_CAN_MODE</code> - This function changes the operating mode of the CAN controller. Possible values for mode are defined in the <code>cyg_can_mode</code> enumeration. Befor the hardware configuration of the device is changed, that means if baudrate is changed or the message buffer and filter configuration is changed, the CAN hardware should be set into stop mode and if configuration is finished, then device should be set back into operational mode. Before the device is set into standby mode, the output buffers should be flushed or drained because transmission of a CAN message may wake up the CAN hardware. If a received message wakes up the CAN hardware from standby mode then a <code>CYGNUM_CAN_EVENT_LEAVING_STANDBY</code> event will be inserted into receive message buffer or the <code>CYGNUM_CAN_EVENT_LEAVING_STANDBY </code>flag will be set for the message that caused wake up of CAN hardware.</p>
		<h2>FlexCAN device driver</h2>
		<p>The FlexCAN module is a communication controller implementing the controller area network (CAN) protocol, an asynchronous communications protocol used in automotive and industrial control systems. It is a high speed (1 Mbit/sec), short distance, priority based protocol which can communicate using a variety of mediums (for example, fiber optic cable or an unshielded twisted pair of wires). The FlexCAN supports both the standard and extended identifier (ID) message formats specified in the CAN protocol specification, revision 2.0, part B.</p>
		<p>It supports up to 16 flexible flexible message buffers of 0-8 bytes data length, each configurable as Rx or Tx, all supporting standard and extended messages.</p>
		<p>The message buffer 16 of the FlexCAN modul is reserved for transmission of CAN messages. Message buffers 1 - 15 are available for configuration of remote buffers and message filters. If the FlexCAN modul is configured for reception of all CAN frames, then the user can select the number of buffers used for reception of CAN frames. The interrupt priority of each message box is configurable.</p>
	</body>

</html>
