<!-- HEY YOU!!!!!!!!! -->
<!-- this file is automatically generated by the script -->
<!--       ./prepare-manpages.sh      -->
<!-- so PLEASE do not modify it: your changes will be lost -->


<chapter id="libipsec-library-reference">
  <title>libipsec Reference</title>


  <sect1 id="net-ipsec-libipsec-man-ipsec-set-policy">
    <title>ipsec_set_policy</title>
    <screen>
IPSEC_SET_POLICY(3)     System Library Functions Manual    IPSEC_SET_POLICY(3)

NAME
     ipsec_set_policy, ipsec_get_policylen, ipsec_dump_policy - manipulate
     IPsec policy specification structure from readable string

LIBRARY
     IPsec Policy Control Library (libipsec, -lipsec)

SYNOPSIS
     #include &lt;netinet6/ipsec.h>

     char *
     ipsec_set_policy(char *policy, int len);

     int
     ipsec_get_policylen(char *buf);

     char *
     ipsec_dump_policy(char *buf, char *delim);

DESCRIPTION
     ipsec_set_policy() generates IPsec policy specification structure, namely
     struct sadb_x_policy and/or struct sadb_x_ipsecrequest from human-read-
     able policy specification.  policy specification must be given as C
     string policy and length len of policy.  ipsec_set_policy() will return
     the buffer of IPsec policy specification structure.  The buffer is dynam-
     ically allocated, and must be freed by the caller by calling free(3).

     You may want the length of the generated buffer such when calling
     setsockopt(2).  ipsec_get_policylen() will return the length.

     ipsec_dump_policy() converts IPsec policy structure into readable form.
     Therefore, ipsec_dump_policy() can be regarded as inverse conversion of
     ipsec_set_policy().  buf points to a IPsec policy structure, struct
     sadb_x_policy.  delim is a delimiter string, which is usually a blank
     character.  If you set delim to NULL, single whitespace is assumed.
     ipsec_dump_policy() returns pointer to dynamically allocated string.  It
     is caller's responsibility to reclaim the region, by using free(3).

     policy is formatted as either of the following:

     direction discard
              direction must be in or out.  direction specifies which direc-
              tion the policy needs to be applied.  With discard policy, pack-
              ets will be dropped if they match the policy.

     direction entrust
              entrust means to consult to SPD defined by setkey(8).

     direction bypass
              bypass means to be bypassed the IPsec processing.  (packet will
              be transmitted in clear).  This is for privileged socket.

     direction ipsec request ...
              ipsec means that the matching packets are subject to IPsec pro-
              cessing.  ipsec can be followed by one or more request string,
              which is formatted as below:

              protocol / mode / src - dst [/level]
                       protocol is either ah, esp or ipcomp.

                       mode is either transport or tunnel.

                       src and dst specifies IPsec endpoint.  src always means
                       ``sending node'' and dst always means ``receiving
                       node''.  Therefore, when direction is in, dst is this
                       node and src is the other node (peer).  If mode is
                       transport, Both src and dst can be omited.

                       level must be set to one of the following: default,
                       use, require or unique.  default means that the kernel
                       should consult the system default policy defined by
                       sysctl(8), such as net.inet.ipsec.esp_trans_deflev.
                       See ipsec(4) regarding the system default.  use means
                       that a relevant SA can be used when available, since
                       the kernel may perform IPsec operation against packets
                       when possible.  In this case, packets can be transmit-
                       ted in clear (when SA is not available), or encrypted
                       (when SA is available).  require means that a relevant
                       SA is required, since the kernel must perform IPsec
                       operation against packets.  unique is the same as
                       require, but adds the restriction that the SA for out-
                       bound traffic is used only for this policy.  You may
                       need the identifier in order to relate the policy and
                       the SA when you define the SA by manual keying.  You
                       can put the decimal number as the identifier after
                       unique like unique: number.  number must be between 1
                       and 32767 .  If the request string is kept unambiguous,
                       level and slash prior to level can be omitted.  How-
                       ever, it is encouraged to specify them explicitly to
                       avoid unintended behaviors.  If level is omitted, it
                       will be interpreted as default.

     Note that there is a bit difference of specification from setkey(8).  In
     specification by setkey(8), both entrust and bypass are not used.  Refer
     to setkey(8) for detail.

     Here are several examples (long lines are wrapped for readability):

           in discard
           out ipsec esp/transport//require
           in ipsec ah/transport//require
           out ipsec esp/tunnel/10.1.1.2-10.1.1.1/use
           in ipsec ipcomp/transport//use
                   esp/transport//use

RETURN VALUES
     ipsec_set_policy() returns a pointer to the allocated buffer of policy
     specification if successful; otherwise a NULL pointer is returned.
     ipsec_get_policylen() returns with positive value (meaning the buffer
     size) on success, and negative value on errors.  ipsec_dump_policy()
     returns a pointer to dynamically allocated region on success, and NULL on
     errors.

SEE ALSO
     ipsec_strerror(3), ipsec(4), setkey(8)

HISTORY
     The functions first appeared in WIDE/KAME IPv6 protocol stack kit.

KAME                              May 5, 1998                             KAME
    </screen>
  </sect1>

  <sect1 id="net-ipsec-libipsec-man-ipsec-strerror">
    <title>ipsec_strerror</title>
    <screen>
IPSEC_STRERROR(3)       System Library Functions Manual      IPSEC_STRERROR(3)

NAME
     ipsec_strerror - error message for IPsec policy manipulation library

SYNOPSIS
     #include &lt;netinet6/ipsec.h>

     const char *
     ipsec_strerror();

DESCRIPTION
     netinet6/ipsec.h declares

           extern int ipsec_errcode;

     which is used to pass an error code from IPsec policy manipulation
     library to an user program.  ipsec_strerror() can be used to obtain the
     error message string for the error code.

     The array pointed to is not to be modified by the program.  Since
     ipsec_strerror() uses strerror(3) as underlying function, calling
     strerror(3) after ipsec_strerror() would make the return value from
     ipsec_strerror() invalid, or overwritten.

RETURN VALUES
     ipsec_strerror() always return a pointer to C string.  The C string must
     not be overwritten by user programs.

SEE ALSO
     ipsec_set_policy(3)

HISTORY
     ipsec_strerror() first appeared in WIDE/KAME IPv6 protocol stack kit.

BUGS
     ipsec_strerror() will return its result which may be overwritten by sub-
     sequent calls.

     ipsec_errcode is not thread safe.

KAME                              May 6, 1998                             KAME
    </screen>
  </sect1>


</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-namecase-general:t
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:("ipsec.sgml" "book" "chapter")
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
sgml-doctype:"book"
End:
-->

